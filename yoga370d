#!/usr/bin/env python3

"""
yoga370d acts on rotation and mode changes

configure it by changing the following config variables
"""

import time
import subprocess
import socket
import logging
import multiprocessing
import atexit
import dbus
from dbus.mainloop.glib import DBusGMainLoop
import re
from pathlib import Path
from fileinput import FileInput
from gi.repository import GLib, Gio

NAME = "yoga370d"

# Set to True to enable screen and digitizer rotation
ROTATE_ACTIVE = True

# Activate onboard in Tablet Mode
KEYBOARD_ACTIVE = True

# command used to restart wm after orientation changes
# set to None if no restart is wanted
WM_RESTART_COMMAND = ['i3-msg', 'restart']

# map sensor-proxy orientation to xrandr and wacom
XRANDR_ORIENTATION_MAP = {
    'right-up': 'right',
    'normal' : 'normal',
    'bottom-up': 'inverted',
    'left-up': 'left'
}

WACOM_ORIENTATION_MAP = {
    'right-up': 'cw',
    'normal' : 'none',
    'bottom-up': 'half',
    'left-up': 'ccw'
}

state = str(Path.home().joinpath(".config/yogad/state.sh"))

def write_state(state_var, state_value):
    """
    finds occurrence of state var and replaces value with updated one
    """
    with FileInput(files=[state], inplace=True) as f:
        state_found = False
        for l in f:
            if l.startswith(state_var.upper() + "="):
                l = state_var.upper() + "=\"" + state_value + "\""
                state_found = True
            print(l, end="")

    if not state_found:
        with open(state, "a") as f:
            f.write(state_var.upper() + "=\"" + state_value + "\"")

def cmd_and_log(cmd):
    """Execute cmd and log it"""
    exit_code = subprocess.call(cmd)
    log.info("running %s with exit code %s", cmd, exit_code)


def sensor_proxy_signal_handler(source, changedProperties, invalidatedProperties, **kwargs):
    """ handle sensor proxy PropertiesChanged which includes screen orientation """
    if source == u'net.hadess.SensorProxy':
        if 'AccelerometerOrientation' in changedProperties and ROTATE_ACTIVE:
            orientation = changedProperties['AccelerometerOrientation']
            log.info("dbus signal indicates orientation change to %s", orientation)

            cmd_and_log(["xrandr", "-o", XRANDR_ORIENTATION_MAP[orientation]])
            for device in wacom:
                cmd_and_log(["xsetwacom", "--set", device, "rotate", WACOM_ORIENTATION_MAP[orientation]])
            if WM_RESTART_COMMAND:
                cmd_and_log(WM_RESTART_COMMAND)


def monitor_acpi_events(touch_and_track):
    """
    listen for the acpi position change event
    
    react on it by:
    - turning input devices off/on 
    - enabling/disabling the on-screen keyboard
    """
    global onboard_proc

    socketACPI = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    socketACPI.connect("/var/run/acpid.socket")

    # ACPI Events used to detect screen orientation
    EventACPIDisplayPositionTablet = b'video/tabletmode TBLT 0000008A 00000001\n'
    EventACPIDisplayPositionLaptop = b'video/tabletmode TBLT 0000008A 00000000\n'

    log.info("connected to acpi socket {}".format(socket))
    while True:
        event = socketACPI.recv(4096)
        log.debug("catching acpi event %s", event)
        if event == EventACPIDisplayPositionTablet:
            log.info("display position change detected, tablet mode enabled")
            for x in touch_and_track:
                cmd_and_log(["xinput", "disable", x])
            if KEYBOARD_ACTIVE:
                subprocess.Popen(["onboard"])
            write_state("mode", "tablet")
            if WM_RESTART_COMMAND:
                cmd_and_log(WM_RESTART_COMMAND)
        elif event == EventACPIDisplayPositionLaptop:
            log.info("display position change detected, laptop mode enabled")
            for x in touch_and_track:
                cmd_and_log(["xinput", "enable", x])
            if KEYBOARD_ACTIVE:
                cmd_and_log(["pkill", "onboard"])
            write_state("mode", "laptop")
            if WM_RESTART_COMMAND:
                cmd_and_log(WM_RESTART_COMMAND)
        time.sleep(0.3)


def monitor_stylus_proximity(stylus, finger_touch):
    """ disable touch if stylus is used """
    out = subprocess.Popen(["xinput", "test", "-proximity", stylus], stdout=subprocess.PIPE)

    for line in out.stdout:
        if (line.startswith(b'proximity')):
            log.debug("stylus is nearby {}".format(line))
            status = line.split(b' ')[1]
            cmd_and_log(["xinput", "disable" if status == b'in' else "enable", finger_touch])


def cleanup(touch_and_track, wacom):
    """ reset all devices to default"""
    cmd_and_log(["xrandr", "-o", "normal"])
    for x in touch_and_track:
        cmd_and_log(["xinput", "enable", x])
    if ROTATE_ACTIVE:
        for device in wacom:
            cmd_and_log(["xsetwacom", "--set", device, "rotate", "none"])
    write_state("mode", "laptop")
    if WM_RESTART_COMMAND:
        cmd_and_log(WM_RESTART_COMMAND)


def main():
    # globals
    global wacom
    global log

    # logging
    log = logging.getLogger()
    logHandler = logging.StreamHandler()
    log.addHandler(logHandler)
    logHandler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
    log.level = logging.DEBUG

    # load wacom devices
    lines = subprocess.check_output(['xsetwacom', '--list', 'devices']).split(b'\n')

    wacom = [x.decode().split('\t')[0] for x in lines if x]
    log.info("detected wacom devices: %s", wacom)

    # load stylus touchpad trackpoint devices
    lines = subprocess.check_output(['xinput','--list', '--name-only']).decode().split('\n')

    # remove disabled devices
    lines.remove('')
    for device in lines:
        try:
            props = subprocess.check_output(['xinput','list-props',device]).decode()
            state = bool(int(re.search('Device Enabled .*([01])\n', props).group(1)))
        except:
            state = False;
        log.info("Device %s is %s", device, 'on' if state else 'off')
        if not state:
            lines.remove(device)

    stylus = next(x for x in lines if "stylus" in x)
    log.info("found stylus %s", stylus)

    finger_touch = next(x for x in lines if "Finger touch" in x)
    log.info("found finger touch %s", finger_touch)

    # it's crucial to have trackpoints first in this list.
    # Otherwise enabling/disabling doesn't work as expected and touchpad just stays enabled always
    touch_and_track = [x for x in lines if "TrackPoint" in x] + [x for x in lines if "Touchpad" in x]
    log.info("found touchpad and trackpoints %s", touch_and_track)

    # listen for ACPI events to detect switching between laptop/tablet mode
    acpi_process = multiprocessing.Process(target=monitor_acpi_events, args=(touch_and_track,))
    acpi_process.start()

    proximity_process = multiprocessing.Process(target=monitor_stylus_proximity, args=(stylus, finger_touch))
    proximity_process.start()

    atexit.register(cleanup, touch_and_track, wacom)

    # init dbus stuff and subscribe to events
    DBusGMainLoop(set_as_default=True)
    bus = dbus.SystemBus()
    proxy = bus.get_object('net.hadess.SensorProxy', '/net/hadess/SensorProxy')
    props = dbus.Interface(proxy, 'org.freedesktop.DBus.Properties')
    props.connect_to_signal('PropertiesChanged', sensor_proxy_signal_handler, sender_keyword='sender')
    iface = dbus.Interface(proxy, 'net.hadess.SensorProxy')
    iface.ClaimAccelerometer()

    loop = GLib.MainLoop()
    loop.run()


if __name__ == "__main__":
    main()
